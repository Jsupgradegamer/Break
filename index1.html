<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Split Break Coverage System - FINAL MULTI-COVERAGE FIX</title>
    <style>
        /* --- CSS Styling (Same as previous version) --- */
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }
        #entry-form-container, #results-container { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); margin-bottom: 25px; }
        h2, h3 { color: #007bff; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        .shift-time-inputs { display: flex; gap: 20px; margin-bottom: 20px; padding: 10px; border: 1px dashed #007bff; border-radius: 5px; }
        .shift-time-inputs .input-group { flex-grow: 1; }
        .entry-row { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 15px; 
            margin-bottom: 15px; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-left: 5px solid #ffc107; 
            border-radius: 6px; 
            align-items: center; 
            position: relative;
        }
        .input-group { display: flex; flex-direction: column; min-width: 120px; }
        .input-group label { font-weight: bold; color: #555; margin-bottom: 4px; font-size: 0.9em; }
        .input-group input[type="text"], .input-group input[type="time"] { padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box; width: 100%; }
        .time-pair { display: flex; gap: 5px; }
        .checkbox-group { display: flex; align-items: center; gap: 5px; margin-top: 5px; font-size: 0.9em;}
        .checkbox-container { display: flex; flex-direction: column; min-width: 150px; margin-top: 10px; padding-right: 15px; border-right: 1px dotted #ccc; } 
        .checkbox-group input[type="checkbox"] { width: auto; }
        .controls { margin-top: 20px; display: flex; gap: 10px; }
        .controls button { padding: 12px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: background-color 0.3s, opacity 0.3s; }
        #add-more-btn { background-color: #28a745; color: white; }
        #submit-btn { background-color: #007bff; color: white; }
        #submit-btn:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.7; }
        #results-container { margin-top: 30px; border-top: 2px solid #007bff; display: none; }
        #coverage-list, #extra-id-list { list-style-type: none; padding: 0; }
        #coverage-list li { background: #e9f5ff; margin-bottom: 8px; padding: 12px; border-left: 5px solid #007bff; border-radius: 4px; font-size: 1.05em; }
        #extra-id-list li { background: #fff3e0; margin-bottom: 8px; padding: 12px; border-left: 5px solid #ff9800; border-radius: 4px; font-size: 1.05em; }
        .warning-message { color: #dc3545; font-weight: bold; padding: 10px 0; border-top: 1px dashed #dc3545; margin-top: 10px; }
        .success-message { color: #28a745; font-weight: bold; padding: 10px 0; border-top: 1px dashed #28a745; margin-top: 10px; }
        .alert-message { background-color: #fff3cd; color: #856404; font-weight: bold; padding: 10px; border: 1px solid #ffeeba; border-radius: 5px; margin-top: 10px; }
        .overload-alert { 
            background-color: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
            font-weight: bold; 
            padding: 15px; 
            border-radius: 5px; 
            margin-top: 15px; 
            box-shadow: 0 0 8px rgba(248, 215, 218, 0.5);
        }
        .remove-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background 0.2s;
        }
        .remove-btn:hover {
            background: #c82333;
        }
    </style>
</head>
<body>

    <div id="entry-form-container">
        <h2>Employee & ID Entry üßë‚Äçüíª</h2>
        <p><strong>Logic:</strong> **Name** without ID/Breaks = **Backup Employee** (Covers breaks, eliminates Extra ID load on Active Employees). **ID** without Name/Breaks = **Extra ID**.</p>

        <div class="shift-time-inputs">
            <div class="input-group">
                <label for="shift-start">Shift Start Time:</label>
                <input type="time" id="shift-start" value="22:30" required>
            </div>
            <div class="input-group">
                <label for="shift-end">Shift End Time:</label>
                <input type="time" id="shift-end" value="07:30" required>
            </div>
        </div>
        
        <div id="overlap-warning-container">
            </div>

        <div id="entries-container">
            </div>

        <div class="controls">
            <button id="add-more-btn">‚ûï Add More Employee/ID</button>
            <button id="submit-btn" disabled>‚úÖ Submit & Calculate Coverage</button>
        </div>
    </div>

    <div id="results-container">
        <h3>Break Coverage Schedule ‚è∞</h3>
        <p id="result-message"></p>
        
        <h4>1. Employee Break Coverage (Kaun Kisko Break De Raha Hai)</h4>
        <ul id="coverage-list">
            </ul>
        
        <h4 style="margin-top: 25px;">2. Extra ID Duty Schedule (Extra ID Kab Chali)</h4>
        <ul id="extra-id-list">
            </ul>
        
        <h4 style="margin-top: 25px;">3. Employee Extra ID Duty Summary (Barabari Ka Check)</h4>
        <p id="duty-summary"></p>
    </div>

    <script>
        // --- JavaScript Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const entriesContainer = document.getElementById('entries-container');
            const addMoreBtn = document.getElementById('add-more-btn');
            const submitBtn = document.getElementById('submit-btn');
            const resultsContainer = document.getElementById('results-container');
            const coverageList = document.getElementById('coverage-list');
            const extraIDList = document.getElementById('extra-id-list'); 
            const resultMessage = document.getElementById('result-message');
            const dutySummary = document.getElementById('duty-summary');
            const shiftStartInput = document.getElementById('shift-start');
            const shiftEndInput = document.getElementById('shift-end');
            const overlapWarningContainer = document.getElementById('overlap-warning-container'); 

            
            let entryCount = 0;

            // Helper functions
            function timeToMinutes(timeStr) {
                if (!timeStr) return null;
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }

            function minutesToTime(totalMinutes) {
                const hours = Math.floor(totalMinutes / 60);
                const minutes = Math.round(totalMinutes % 60); 
                
                const displayHours = hours % 24; 
                return `${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }
            
            function calculateShiftDuration(start, end) {
                if (!start || !end) return 0;
                const startMin = timeToMinutes(start);
                const endMin = timeToMinutes(end);
                return (endMin > startMin) ? (endMin - startMin) : (endMin + (24 * 60) - startMin);
            }
            
            // --- Remove Function ---
            window.removeEntry = function(button) {
                const row = button.closest('.entry-row');
                if (row) {
                    row.remove();
                    checkValidation(); 
                }
            };

            function createEntryRow(idValue = '', nameValue = '', isCOEChecked = false, isBOEChecked = false, break1Start = '', break1End = '', break2Start = '', break2End = '') {
                entryCount++;
                const row = document.createElement('div');
                row.className = 'entry-row';
                row.dataset.entryIndex = entryCount;

                row.innerHTML = `
                    <button class="remove-btn" onclick="removeEntry(this)">‚úñ</button>
                    <div class="input-group" style="flex-grow: 0.5;">
                        <label>ID (Optional for Backup):</label>
                        <input type="text" class="employee-id" placeholder="ID" value="${idValue}">
                    </div>
                    
                    <div class="checkbox-container">
                        <label style="font-size: 1em; margin-bottom: 5px;">Employee Type:</label>
                        <div class="checkbox-group">
                            <input type="checkbox" class="is-coe-checkbox" id="coe-${entryCount}" ${isCOEChecked ? 'checked' : ''}>
                            <label for="coe-${entryCount}">Coverage Only (COE)</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" class="is-boe-checkbox" id="boe-${entryCount}" ${isBOEChecked ? 'checked' : ''}>
                            <label for="boe-${entryCount}">Break Only (BOE)</label>
                        </div>
                    </div>
                    
                    <div class="input-group" style="flex-grow: 1.5;">
                        <label>Name (Compulsory for Backup):</label>
                        <input type="text" class="employee-name" placeholder="Name" value="${nameValue}">
                    </div>
                    
                    <div class="input-group">
                        <label>Break 1 (Start-End):</label>
                        <div class="time-pair">
                            <input type="time" class="break-start-1" title="Break 1 Start" value="${break1Start}">
                            <input type="time" class="break-end-1" title="Break 1 End" value="${break1End}">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Break 2 (Start-End):</label>
                        <div class="time-pair">
                            <input type="time" class="break-start-2" title="Break 2 Start" value="${break2Start}">
                            <input type="time" class="break-end-2" title="Break 2 End" value="${break2End}">
                        </div>
                    </div>
                `;
                entriesContainer.appendChild(row);
                
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => input.addEventListener('input', checkValidation));
                
                // Add listeners to checkboxes to manage mutual exclusion (BOE overrides COE/Active)
                const coeCheckbox = row.querySelector('.is-coe-checkbox');
                const boeCheckbox = row.querySelector('.is-boe-checkbox');

                coeCheckbox.addEventListener('change', () => {
                    if (coeCheckbox.checked) {
                        boeCheckbox.checked = false; 
                    }
                    checkValidation();
                });
                boeCheckbox.addEventListener('change', () => {
                    if (boeCheckbox.checked) {
                        coeCheckbox.checked = false; 
                    }
                    checkValidation();
                });
            }

            // --- CORE LOGIC START ---

            function getBreaksData() {
                const shiftStartInputVal = shiftStartInput.value.trim();
                const shiftStartMin = timeToMinutes(shiftStartInputVal);
                if (!shiftStartMin) return { allBreaks: [], activeEmployees: [], coeEmployees: [], boeEmployees: [], extraIDs: [], backupEmployees: [] };

                const activeEmployees = []; 
                const coeEmployees = [];      
                const boeEmployees = [];      
                const extraIDs = []; 
                const backupEmployees = []; 
                
                document.querySelectorAll('.entry-row').forEach(row => {
                    const id = row.querySelector('.employee-id').value.trim();
                    const name = row.querySelector('.employee-name').value.trim();
                    const isCOE = row.querySelector('.is-coe-checkbox').checked;
                    const isBOE = row.querySelector('.is-boe-checkbox').checked;

                    const breaks = [
                        { start: row.querySelector('.break-start-1').value, end: row.querySelector('.break-end-1').value },
                        { start: row.querySelector('.break-start-2').value, end: row.querySelector('.break-end-2').value }
                    ].filter(b => b.start && b.end).map(b => {
                        let startMin = timeToMinutes(b.start);
                        let endMin = timeToMinutes(b.end);
                        
                        // Break Normalization for Cross-Midnight Shift (22:30 -> 07:30)
                        if (startMin < shiftStartMin && timeToMinutes(b.start) < timeToMinutes(shiftStartInputVal)) {
                             startMin += (24 * 60); // Break is on the next calendar day, so add 24 hours
                        }
                        if (endMin < startMin) endMin += (24 * 60); // Break crosses midnight (e.g., 23:30 to 00:00)
                        
                        b.duration = endMin - startMin; 
                        return { ...b, startMin, endMin, originalStartMin: startMin };
                    });

                    // Skip if both ID and Name are empty (an empty row)
                    if (!id && !name) return; 

                    if (isBOE) {
                        boeEmployees.push({ id, name: name || `ID: ${id}`, breaks });
                    } else if (isCOE) {
                        coeEmployees.push({ id, name: name || `ID: ${id}`, breaks });
                    } else if (breaks.length > 0 && name && id) {
                        // Active Employee (Has ID, Name, and Breaks)
                        activeEmployees.push({ id, name: name || `ID: ${id}`, breaks });
                    } else {
                        // NEW LOGIC: Distinguish Extra ID from Backup Employee
                        if (name && !breaks.length) { 
                             // Backup Employee: Has Name, but no breaks, and not COE/BOE
                            backupEmployees.push({ id, name: name });
                        } else if (id && !breaks.length) {
                             // Extra ID: Has ID, no name, and no breaks
                            extraIDs.push({ id, name: `EXTRA ID (${id})` });
                        } else if (breaks.length > 0) {
                             // Active Employee with missing Name/ID data (fallback to Active if breaks present)
                             activeEmployees.push({ id, name: name || `ID: ${id}`, breaks });
                        }
                    }
                });

                let allBreaks = [];
                activeEmployees.forEach(emp => emp.breaks.forEach((b) => { allBreaks.push({ employee: emp, breakTime: b, isBOE: false, isCOE: false }); }));
                coeEmployees.forEach(emp => emp.breaks.forEach((b) => { allBreaks.push({ employee: emp, breakTime: b, isBOE: false, isCOE: true }); })); 
                boeEmployees.forEach(emp => emp.breaks.forEach((b) => { allBreaks.push({ employee: emp, breakTime: b, isBOE: true, isCOE: false }); })); 
                
                // Sort by break start time for sequential processing and overlap check
                allBreaks.sort((a, b) => a.breakTime.startMin - b.breakTime.startMin);
                
                return { allBreaks, activeEmployees, coeEmployees, boeEmployees, extraIDs, backupEmployees };
            }


            // --- Break Status Check (MODIFIED for Pre-Submit Alert) ---
            function displayBreakStatus(allBreaks, numBackups) {
                overlapWarningContainer.innerHTML = '';
                let adjustedListHTML = '';
                
                if (numBackups > 0) {
                    // --- Backup Overload Check (New Logic for Pre-Submit) ---
                    const backupCapacity = numBackups * 2;
                    let lastBreakStartMin = null;
                    let breakSequenceCounter = 0;
                    let overloadDetected = false;
                    let overloadBreakInfo = null;

                    allBreaks.forEach(breakSlot => {
                        const currentBreakStartMin = breakSlot.breakTime.startMin;
                        
                        if (currentBreakStartMin !== lastBreakStartMin) {
                            breakSequenceCounter = 1;
                        } else {
                            breakSequenceCounter++;
                        }
                        lastBreakStartMin = currentBreakStartMin;

                        if (breakSequenceCounter > backupCapacity && !overloadDetected) {
                            overloadDetected = true;
                            overloadBreakInfo = { count: breakSequenceCounter, time: minutesToTime(currentBreakStartMin) };
                        }
                    });

                    if (overloadDetected) {
                        overlapWarningContainer.innerHTML = `<div class="overload-alert">
                            üö® **OVERLOAD ALERT (Pre-Submit):**
                            <p style="margin-top: 10px; margin-bottom: 5px;">‡§Ü‡§™‡§ï‡•á **${numBackups} Backup Employees** ‡§ï‡•Ä ‡§ï‡•Å‡§≤ **${backupCapacity}** ‡§¨‡•ç‡§∞‡•á‡§ï ‡§è‡§ï ‡§∏‡§æ‡§• ‡§∏‡§Ç‡§≠‡§æ‡§≤‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ç‡§∑‡§Æ‡§§‡§æ ‡§™‡§æ‡§∞ ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</p>
                            <p><strong>Overload at:</strong> ${overloadBreakInfo.time} (**${overloadBreakInfo.count}** breaks simultaneously).</p>
                            <p style="font-weight: bold; color: #721c24;">‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§¨‡§¶‡§≤‡•á‡§Ç ‡§§‡§æ‡§ï‡§ø Active Employees ‡§™‡§∞ ‡§¨‡•ã‡§ù ‡§® ‡§™‡§°‡§º‡•á‡•§</p>
                        </div>`;
                        // Don't disable submit, but show a strong warning
                        return { disableSubmit: false }; 
                    } else {
                        overlapWarningContainer.innerHTML = `<div class="success-message">‚úÖ **‡§¨‡•à‡§ï‡§Ö‡§™ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß:** ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ì‡§µ‡§∞‡§≤‡•à‡§™ ‡§ö‡•á‡§ï ‡§∏‡§´‡§≤‡•§ **${numBackups} Backup Employee** ‡§è‡§ï ‡§∏‡§æ‡§• **${backupCapacity}** ‡§¨‡•ç‡§∞‡•á‡§ï ‡§§‡§ï ‡§∏‡§Ç‡§≠‡§æ‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</div>`;
                    }
                    return {}; 
                } 
                
                // --- Sequential Adjustment Logic (If No Backup) ---
                let lastEndTime = null;
                allBreaks.forEach(breakSlot => {
                    let currentBreak = breakSlot.breakTime;
                    
                    if (lastEndTime !== null && currentBreak.startMin < lastEndTime) {
                        const originalStart = minutesToTime(currentBreak.originalStartMin);
                        const newStartMin = lastEndTime;
                        const newEndMin = newStartMin + currentBreak.duration;
                        const newStart = minutesToTime(newStartMin);
                        const newEnd = minutesToTime(newEndMin);

                        currentBreak.startMin = newStartMin;
                        currentBreak.endMin = newEndMin;
                        
                        adjustedListHTML += `<li>üö® **ADJUSTED:** **${breakSlot.employee.name || breakSlot.employee.id}**'s break (**${originalStart} - ${minutesToTime(currentBreak.originalStartMin + currentBreak.duration)}**) was overlapping and moved to **${newStart} - ${newEnd}**.</li>`;
                    }
                    
                    lastEndTime = currentBreak.endMin;
                });

                if (adjustedListHTML) {
                    overlapWarningContainer.innerHTML = `<div class="alert-message">‚ö†Ô∏è **BREAK ADJUSTMENT ALERT (No Backup):**<ul>${adjustedListHTML}</ul><p>The calculation will proceed with the **adjusted times** to ensure ID coverage.</p></div>`;
                }
                return {};
            }


            function checkValidation() {
                const allEntries = document.querySelectorAll('.entry-row');
                const minTwoEntries = allEntries.length >= 2;
                
                const shiftStartFilled = shiftStartInput.value.trim() !== '';
                const shiftEndFilled = shiftEndInput.value.trim() !== '';

                let minimumDataFilled = false;
                
                allEntries.forEach(row => {
                    const idInput = row.querySelector('.employee-id');
                    const nameInput = row.querySelector('.employee-name');
                    if ((idInput && idInput.value.trim() !== '') || (nameInput && nameInput.value.trim() !== '')) {
                        minimumDataFilled = true;
                    } 
                });

                if (minTwoEntries && minimumDataFilled && shiftStartFilled && shiftEndFilled) {
                    submitBtn.disabled = false;
                } else {
                    submitBtn.disabled = true;
                }
                
                if (submitBtn.disabled === false) {
                     const { allBreaks, backupEmployees } = getBreaksData();
                     // Use the new status checker function
                     displayBreakStatus(allBreaks, backupEmployees.length);
                } else {
                     overlapWarningContainer.innerHTML = ''; 
                }
            }
            
            // -------------------------------------------------------------------------------------
            // --- Pre-fill Logic (Backup Boy 1 and 2 added for testing equal distribution) ---
            // -------------------------------------------------------------------------------------
            createEntryRow('alok.k', 'Alok Kumar', false, false, '01:00', '01:30', '05:30', '06:00'); 
            createEntryRow('bishal.y', 'BISHAL YADAV', false, false, '01:00', '01:30', '05:30', '06:00'); // Changed BISHAL's break time to 01:00 for overlapping test
            createEntryRow('ava.m', 'Avaneesh Mishra', true, false, '01:30', '02:00', '05:00', '05:30'); 
            createEntryRow('', 'Backup Boy 1', false, false, '', '', '', ''); // Backup Employee 1 (Only Name)
            createEntryRow('', 'Backup Girl 2', false, false, '', '', '', ''); // Backup Employee 2 (Only Name)
            createEntryRow('ajay.s', 'Ajay Singh', false, true, '01:30', '02:00', '05:30', '06:00'); // Changed Ajay's break time for overlapping test
            
            // Event listeners
            shiftStartInput.addEventListener('input', checkValidation);
            shiftEndInput.addEventListener('input', checkValidation);
            
            addMoreBtn.addEventListener('click', () => {
                createEntryRow(); 
                checkValidation();
            });
            checkValidation();
            
            // --- CORE CALCULATION LOGIC ---
            submitBtn.addEventListener('click', () => {
                checkValidation();
                if (submitBtn.disabled) return; 

                // Reset containers
                resultsContainer.style.display = 'block';
                coverageList.innerHTML = '';
                extraIDList.innerHTML = ''; 
                resultMessage.innerHTML = '';
                dutySummary.innerHTML = '';
                
                const shiftStartTime = shiftStartInput.value.trim();
                const shiftEndTime = shiftEndInput.value.trim(); 
                const SHIFT_START_MIN = timeToMinutes(shiftStartTime);
                let SHIFT_END_MIN = timeToMinutes(shiftEndTime);
                const SHIFT_DURATION_MIN = calculateShiftDuration(shiftStartTime, shiftEndTime);
                
                if (SHIFT_END_MIN < SHIFT_START_MIN) {
                    SHIFT_END_MIN += (24 * 60);
                }
                
                const { allBreaks, activeEmployees, coeEmployees, boeEmployees, extraIDs, backupEmployees } = getBreaksData();
                const numBackups = backupEmployees.length; 
                
                // Re-run the break check/adjustment logic (it modifies break times if no backup)
                displayBreakStatus(allBreaks, numBackups); 

                // Recalculate break load based on potentially adjusted times
                let activeEmployeeBreakLoad = 0;
                
                allBreaks.forEach(slot => {
                    const duration = slot.breakTime.endMin - slot.breakTime.startMin;
                    if (slot.isBOE || slot.isCOE) {
                        activeEmployeeBreakLoad += duration;
                    }
                });

                
                const numActiveEmployees = activeEmployees.length;
                const numExtraIDs = extraIDs.length;
                
                
                if (numActiveEmployees === 0 && (numExtraIDs > 0 || allBreaks.length > 0)) {
                     resultMessage.innerHTML = '<div class="warning-message">‚ö†Ô∏è **ERROR:** Duty ke liye koi Active Employee nahi hai. Duty/Extra ID cover nahi ho sakti.</div>';
                    return;
                }
                
                const breakCoverageSchedule = []; 
                let extraIDDutySchedule = [];   
                
                const employeeDutyInitialTime = {}; 
                activeEmployees.forEach(emp => employeeDutyInitialTime[emp.name] = 0);
                
                
                // --- Determine Total Shift Load ---
                let totalShiftExtraIDLoad = 0;
                if (numExtraIDs > 0) {
                    totalShiftExtraIDLoad = SHIFT_DURATION_MIN * numExtraIDs;
                } else if (numBackups > 0) {
                    totalShiftExtraIDLoad = 0; 
                }
                
                const requiredTotalExtraIDTime = totalShiftExtraIDLoad; 
                
                let requiredDutyPerEmployee = 0;
                if (numActiveEmployees > 0) {
                    requiredDutyPerEmployee = requiredTotalExtraIDTime / numActiveEmployees; 
                }
                
                const allGivers = [...activeEmployees, ...coeEmployees];
                const numAllGivers = allGivers.length;
                
                
                if (numAllGivers + numBackups > 0) {
                    
                    // --- 3. Break Coverage Duty Assignment (WITH DYNAMIC BACKUP & EQUAL DISTRIBUTION) ---
                    let extraIDIndex = 0; 
                    let activeBreakCoverageIndex = 0; 
                    let activeGiverCycleIndexForOverlap = 0; 
                    let breakSequenceCounter = 0; 
                    let lastBreakStartMin = null; 
                    
                    const backupCapacity = numBackups * 2; 
                    // FIX: Persistent counter for strict round-robin assignment across all breaks
                    let totalBreaksAssignedToBackups = 0; 

                    allBreaks.forEach((breakSlot) => {
                        const receiver = breakSlot.employee;
                        const receiverName = receiver.name || receiver.id;
                        const breakTime = breakSlot.breakTime;
                        const duration = breakTime.endMin - breakTime.startMin;
                        let giver1; 

                        // --- Break Sequence Counter Logic (for simultaneous breaks) ---
                        if (breakTime.startMin !== lastBreakStartMin) {
                            breakSequenceCounter = 1; // Reset counter for a new start time
                        } else {
                            breakSequenceCounter++; // Increment if break starts at the exact same time
                        }
                        lastBreakStartMin = breakTime.startMin;
                        // -----------------------------------------------------------

                        if (numBackups > 0) {
                            // PRIORITY 1: Backup covers the break (Dynamic N*2 break limit)
                            if (breakSequenceCounter <= backupCapacity) { 
                                
                                // FIX APPLIED: Use a persistent counter for strict round-robin assignment
                                const backupCycleIndex = totalBreaksAssignedToBackups % numBackups; // Cycles: 0, 1, 0, 1, 0, 1...
                                giver1 = backupEmployees[backupCycleIndex]; 
                                
                                totalBreaksAssignedToBackups++; // Increment persistent counter

                                breakCoverageSchedule.push({
                                    giver: giver1.name, receiver: receiverName, startMin: breakTime.startMin, endMin: breakTime.endMin,
                                    isBOEBreak: breakSlot.isBOE, isCOEBreak: breakSlot.isCOE, isBackup: true,
                                    note: `Backup Coverage (${breakSequenceCounter}th simultaneous break) - ${giver1.name} (Assigned Break ${totalBreaksAssignedToBackups})`,
                                    isOverloadCoverage: false
                                });
                            } else {
                                // Break exceeds total backup capacity (e.g., 5th break with 2 backups)
                                if (numActiveEmployees > 0) {
                                    giver1 = activeEmployees[activeGiverCycleIndexForOverlap % numActiveEmployees];
                                    activeGiverCycleIndexForOverlap++; 
                                    
                                    breakCoverageSchedule.push({
                                        giver: giver1.name, receiver: receiverName, startMin: breakTime.startMin, endMin: breakTime.endMin,
                                        isBOEBreak: breakSlot.isBOE, isCOEBreak: breakSlot.isCOE, isBackup: false,
                                        note: `Active Employee Coverage (${breakSequenceCounter}th simultaneous break - Backup capacity exceeded)`,
                                        isOverloadCoverage: true 
                                    });
                                } else {
                                    giver1 = { name: 'UNCOVERED' };
                                }
                            }

                            // EXTRA ID DUTY: Always SKIPPED/0 load for Active Employees if Backup exists.
                            
                        } else if (breakSlot.isBOE || breakSlot.isCOE) {
                            // PRIORITY 2: No Backup, use Active Giver for BOE/COE 
                            
                            if (numActiveEmployees > 0) {
                                giver1 = activeEmployees[activeBreakCoverageIndex % numActiveEmployees];
                                activeBreakCoverageIndex++; 
                            
                                breakCoverageSchedule.push({ giver: giver1.name, receiver: receiverName, startMin: breakTime.startMin, endMin: breakTime.endMin, isBOEBreak: breakSlot.isBOE, isCOEBreak: breakSlot.isCOE, isOverloadCoverage: false });
                                
                                // Assign duty for BOE/COE coverage
                                extraIDDutySchedule.push({ giver: giver1.name, extraID: `BOE/COE Coverage (${receiverName})`, startMin: breakTime.startMin, endMin: breakTime.endMin });
                                employeeDutyInitialTime[giver1.name] += duration;
                            } 
                            
                        } else { 
                            // PRIORITY 3: No Backup, Active Employee's Break, use All Givers cycle 

                            const receiverIndexInAllGivers = allGivers.findIndex(e => e.id === receiver.id);
                            allGiversIndex = (receiverIndexInAllGivers + 1) % numAllGivers;
                            giver1 = allGivers[allGiversIndex];

                            breakCoverageSchedule.push({ giver: giver1.name, receiver: receiverName, startMin: breakTime.startMin, endMin: breakTime.endMin, isBOEBreak: false, isCOEBreak: false, isOverloadCoverage: false });

                            if (numExtraIDs > 0) {
                                let activeGiverIndex = extraIDIndex % numActiveEmployees;
                                let giver2 = activeEmployees[activeGiverIndex];

                                const extraIDSlot = extraIDs[extraIDIndex % numExtraIDs];
                                extraIDDutySchedule.push({ giver: giver2.name, extraID: extraIDSlot.name, startMin: breakTime.startMin, endMin: breakTime.endMin });
                                
                                employeeDutyInitialTime[giver2.name] += duration;
                                extraIDIndex = (extraIDIndex + 1); 
                            }
                        }
                    });
                
                    
                    // --- 4. Gap Filling Logic (Unchanged) ---
                    
                    if (requiredTotalExtraIDTime > 0) { 
                        
                        const occupiedSegments = extraIDDutySchedule.map(slot => ({ start: slot.startMin, end: slot.endMin }));
                        occupiedSegments.unshift({ start: SHIFT_START_MIN, end: SHIFT_START_MIN });
                        occupiedSegments.push({ start: SHIFT_END_MIN, end: SHIFT_END_MIN }); 
                        occupiedSegments.sort((a, b) => a.start - b.start);
                        
                        const activeEmployeeCycle = activeEmployees.map(e => e.name);
                        let cycleIndex = 0; 
                        
                        const dutyTracking = {};
                        activeEmployees.forEach(emp => dutyTracking[emp.name] = employeeDutyInitialTime[emp.name]);
                        
                        for (let i = 0; i < occupiedSegments.length - 1; i++) {
                            let gapStart = occupiedSegments[i].end;
                            let gapEnd = occupiedSegments[i + 1].start;

                            if (gapEnd > gapStart) {
                                let currentGapTime = gapEnd - gapStart;
                                let currentDutyStart = gapStart;
                                
                                while (currentGapTime > 0) {
                                    
                                    let giverName = null;
                                    let remainingDutyForGiver = 0;
                                    let attempts = 0;
                                    const maxAttempts = activeEmployeeCycle.length;

                                    while (attempts < maxAttempts) {
                                        const potentialGiverName = activeEmployeeCycle[cycleIndex % numActiveEmployees];
                                        const giverTotalDuty = dutyTracking[potentialGiverName] || 0;
                                        remainingDutyForGiver = requiredDutyPerEmployee - giverTotalDuty;
                                        
                                        if (remainingDutyForGiver > 0.1) {
                                            giverName = potentialGiverName;
                                            break;
                                        }
                                        cycleIndex++; 
                                        attempts++;
                                    }
                                    
                                    if (!giverName) {
                                        break; 
                                    }
                                    
                                    const timeToAssign = Math.min(currentGapTime, remainingDutyForGiver);
                                    
                                    if (timeToAssign > 0.1) {
                                        let dutyEnd = currentDutyStart + timeToAssign;
                                        
                                        const extraIDName = (numExtraIDs > 0) ? extraIDs[extraIDIndex % numExtraIDs].name : 'Error: No Extra ID assigned';

                                        extraIDDutySchedule.push({ giver: giverName, extraID: extraIDName, startMin: currentDutyStart, endMin: dutyEnd, dutyType: 'Gap Filling' });
                                        
                                        currentDutyStart = dutyEnd;
                                        currentGapTime -= timeToAssign;
                                        dutyTracking[giverName] += timeToAssign;
                                        
                                        if (Math.abs(timeToAssign - remainingDutyForGiver) < 0.1 && remainingDutyForGiver !== currentGapTime) {
                                            cycleIndex++; 
                                        }
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        // If no Extra ID load is required (due to no Extra ID or Backup handling it), Gap Filling is skipped.
                        extraIDDutySchedule = [];
                        activeEmployees.forEach(emp => employeeDutyInitialTime[emp.name] = 0);
                    }
                }


                // --- 5. Display Results and Summary ---
                
                function formatDutyItem(item) {
                    const duration = Math.round(item.endMin - item.startMin);
                    const formattedStart = minutesToTime(item.startMin);
                    const formattedEnd = minutesToTime(item.endMin);
                    const dutyLabel = item.receiver;
                    let verb;
                    const note = item.note ? `[${item.note}]` : ''; 
                    
                    if (item.isBackup) {
                        // Backup person is explicitly mentioned in the note
                        verb = `(BACKUP) will cover **${dutyLabel}'s break**`;
                    } else if (item.isBOEBreak) {
                        verb = `will cover **BOE's break** (${dutyLabel})`;
                    } else if (item.isCOEBreak) {
                        verb = `will cover **COE's break** (${dutyLabel})`;
                    } else if (item.isOverloadCoverage) {
                        // Highlight Active Employee doing overload coverage
                        verb = `will cover **${dutyLabel}'s break** <span style="color:#dc3545; font-weight:bold;">(OVERLOAD)</span>`;
                    }
                    else {
                         verb = `will cover **${dutyLabel}'s break**`;
                    }
                    return `**${item.giver}** ${verb} from **${formattedStart} - ${formattedEnd}** (${duration} mins) ${note}`;
                }
                
                function formatExtraIDItem(item) {
                    const duration = Math.round(item.endMin - item.startMin);
                    const formattedStart = minutesToTime(item.startMin);
                    const formattedEnd = minutesToTime(item.endMin);
                    let dutyType = item.extraID.startsWith('BOE/COE') ? 'Break Coverage Duty' : 'Extra ID Run';
                    if (item.dutyType === 'Gap Filling') dutyType = 'Gap Filling (Extra ID Run)';
                    return `**${item.giver}** will run **${item.extraID}** (${dutyType}) from **${formattedStart} - ${formattedEnd}** (${duration} mins)`;
                }


                breakCoverageSchedule.forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = formatDutyItem(item);
                    coverageList.appendChild(li);
                });
                if (breakCoverageSchedule.length === 0) coverageList.innerHTML = '<li>No breaks entered for coverage.</li>';
                
                
                let totalExtraIDTime = 0;
                extraIDDutySchedule.sort((a, b) => a.startMin - b.startMin); 
                
                const employeeDutyFinalTotal = {}; 
                activeEmployees.forEach(emp => employeeDutyFinalTotal[emp.name] = 0);
                
                // Track backup time separately for summary
                const backupDutyFinalTotal = {};
                backupEmployees.forEach(emp => backupDutyFinalTotal[emp.name] = 0);

                // Recalculate final totals based on the complete schedule
                extraIDDutySchedule.forEach(item => {
                    const duration = item.endMin - item.startMin;
                    totalExtraIDTime += duration;
                    
                    if (activeEmployees.some(e => e.name === item.giver)) {
                        employeeDutyFinalTotal[item.giver] += duration; 
                    }
                    
                    const li = document.createElement('li');
                    li.innerHTML = formatExtraIDItem(item);
                    extraIDList.appendChild(li);
                });
                
                // Aggregate backup duty time
                breakCoverageSchedule.filter(b => b.isBackup).forEach(item => {
                    const duration = item.endMin - item.startMin;
                    if (backupDutyFinalTotal.hasOwnProperty(item.giver)) {
                        backupDutyFinalTotal[item.giver] += duration;
                    }
                });


                if (extraIDDutySchedule.length === 0 && numExtraIDs > 0) extraIDList.innerHTML = '<li>Error: Extra IDs cannot be scheduled without Active Employees.</li>';
                if (extraIDDutySchedule.length === 0 && requiredTotalExtraIDTime === 0) extraIDList.innerHTML = '<li>No Extra ID load was generated (No Extra ID found or Backup Employee is present).</li>';


                let summaryHTML = '<ul>';
                const allEmployees = [...activeEmployees, ...coeEmployees, ...boeEmployees, ...backupEmployees];

                for (const emp of allEmployees) {
                    const name = emp.name;
                    let role = 'Unknown';
                    if (activeEmployees.some(e => e.name === name)) role = 'Active';
                    else if (coeEmployees.some(e => e.name === name)) role = 'COE';
                    else if (boeEmployees.some(e => e.name === name)) role = 'BOE';
                    else if (backupEmployees.some(e => e.name === name)) role = 'Backup';
                    
                    let dutyTime = employeeDutyFinalTotal[name] || 0;
                    
                    // For Active Employees, show Target vs Actual
                    if (role === 'Active') {
                        const target = Math.round(requiredDutyPerEmployee);
                        const status = Math.abs(dutyTime - target) < 1 ? '‚úÖ Met Target' : (dutyTime > target ? '‚ö†Ô∏è Over Target' : '‚ùå Under Target');
                        summaryHTML += `<li>**${name}** (${role}): **${Math.round(dutyTime)}** minutes (**${(dutyTime / 60).toFixed(2)}** hours) [Target: ${target} mins] - *${status}*</li>`;
                    } else if (role === 'Backup') {
                        // Backup's duty is just break coverage
                        const breakTimeGiven = backupDutyFinalTotal[name] || 0;
                        summaryHTML += `<li>**${name}** (${role}): Break Coverage Given: **${breakTimeGiven}** minutes (**${(breakTimeGiven / 60).toFixed(2)}** hours)</li>`;
                    } else {
                        summaryHTML += `<li>**${name}** (${role}): ${Math.round(dutyTime)} minutes (${(dutyTime / 60).toFixed(2)} hours)</li>`;
                    }
                }
                summaryHTML += '</ul>';
                dutySummary.innerHTML = summaryHTML;


                // --- 6. Final Check ---
                const requiredTotalExtraIDTimeCheck = totalShiftExtraIDLoad;
                const requiredTotalExtraIDTimeHours = requiredTotalExtraIDTimeCheck / 60; 
                const totalExtraIDTimeHours = totalExtraIDTime / 60;
                const requiredDutyPerEmployeeHours = requiredDutyPerEmployee / 60;
                
                let checkMessage = '';
                
                if (requiredTotalExtraIDTimeCheck === 0) {
                     checkMessage = `<div class="success-message">‚úÖ **Shift ID Status:** <ul>
                            <li>Shift Duration: **${SHIFT_DURATION_MIN/60} hours**.</li>
                            <li>Total Extra ID Duty Required: **0.00 hours** (Backup Employee is present or no Extra ID was entered).</li>
                            <li>Status: **SUCCESS!** Active Employees ‡§™‡§∞ ‡§ï‡•ã‡§à Extra ID load ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ Backup Employee break cover ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à‡•§</li>
                        </ul></div>`;
                } else if (numActiveEmployees > 0) {
                    if (Math.abs(requiredTotalExtraIDTimeCheck - totalExtraIDTime) < 1) { 
                         checkMessage = `<div class="success-message">‚úÖ **Shift ID Completion Check (Active Employees):** <ul>
                            <li>Shift Duration: **${SHIFT_DURATION_MIN/60} hours**. Total BOE + COE Break Load: **${(activeEmployeeBreakLoad)/60} hours** (${activeEmployeeBreakLoad} mins).</li>
                            <li>Total Extra ID Duty Required: **${requiredTotalExtraIDTimeHours.toFixed(2)} hours** (${Math.round(requiredTotalExtraIDTimeCheck)} mins).</li>
                            <li>Total Extra ID Duty Scheduled: **${totalExtraIDTimeHours.toFixed(2)} hours** (${Math.round(totalExtraIDTime)} mins).</li>
                            <li>Status: **SUCCESS!** Extra ID load poora cover ho gaya hai. Har **Active Employee** ka Target: **${requiredDutyPerEmployeeHours.toFixed(2)} hours** (${Math.round(requiredDutyPerEmployee)} mins).</li>
                        </ul></div>`;
                    } else {
                        const remainingTime = (requiredTotalExtraIDTimeCheck - totalExtraIDTime) / 60;
                        checkMessage = `<div class="warning-message">‚ö†Ô∏è **SHIFT ID COMPLETION FAILED:** Extra ID load (BOE + COE break time included) poora cover nahi hua. **${remainingTime.toFixed(2)} hours** baaki hai.</div>`;
                    }
                } else {
                    checkMessage = `<div class="warning-message">‚ö†Ô∏è **SYSTEM ERROR:** No Active Employees to handle the Extra ID duty load.</div>`;
                }
                
                resultMessage.innerHTML += checkMessage;
                
                
                // --- 7. Overload Alert Check (Post-Submit) ---
                let overloadAlerts = [];
                breakCoverageSchedule.forEach(item => {
                    if (item.isOverloadCoverage) {
                        const breakTime = `${minutesToTime(item.startMin)} - ${minutesToTime(item.endMin)}`;
                        const simultaneousBreaks = parseInt(item.note.match(/(\d+)th simultaneous break/)[1]);

                        overloadAlerts.push(`<li>**${item.giver}** (**Active Employee**) ‡§ï‡•ã **${item.receiver}** ‡§ï‡§æ ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ï‡§µ‡§∞ ‡§ï‡§∞‡§®‡§æ ‡§™‡§°‡§º‡§æ (**${breakTime}**) ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§â‡§∏ ‡§∏‡§Æ‡§Ø **${simultaneousBreaks} ‡§¨‡•ç‡§∞‡•á‡§ï** ‡§è‡§ï ‡§∏‡§æ‡§• ‡§ì‡§µ‡§∞‡§≤‡•à‡§™ ‡§π‡•ã ‡§∞‡§π‡•á ‡§•‡•á (‡§Ü‡§™‡§ï‡•Ä **${numBackups} Backup** ‡§ï‡•Ä ‡§∏‡•Ä‡§Æ‡§æ **${numBackups * 2}** ‡§•‡•Ä)‡•§</li>`);
                    }
                });

                if (overloadAlerts.length > 0) {
                    const alertHTML = `<div class="overload-alert">
                        ‚ö†Ô∏è **‡§¨‡•ç‡§∞‡•á‡§ï ‡§ì‡§µ‡§∞‡§≤‡•ã‡§° ‡§Ö‡§≤‡§∞‡•ç‡§ü (Backup ‡§ï‡•Ä ‡§∏‡•Ä‡§Æ‡§æ ‡§™‡§æ‡§∞)**
                        <p style="margin-top: 10px; margin-bottom: 5px;">‡§Ü‡§™‡§ï‡•á **Backup Employees** ‡§ï‡•Ä ‡§ï‡•Å‡§≤ **${numBackups * 2}** ‡§¨‡•ç‡§∞‡•á‡§ï ‡§è‡§ï ‡§∏‡§æ‡§• ‡§∏‡§Ç‡§≠‡§æ‡§≤‡§®‡•á ‡§ï‡•Ä ‡§∏‡•Ä‡§Æ‡§æ ‡§™‡§æ‡§∞ ‡§π‡•ã ‡§ó‡§à‡•§ ‡§á‡§∏‡§≤‡§ø‡§è, ‡§ï‡•Å‡§õ **Active Employees** ‡§ï‡•ã ‡§è‡§ï‡•ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§æ ‡§¨‡•ç‡§∞‡•á‡§ï ‡§ï‡§µ‡§∞‡•á‡§ú ‡§°‡•ç‡§Ø‡•Ç‡§ü‡•Ä ‡§ï‡§∞‡§®‡•Ä ‡§™‡§°‡§º‡•Ä‡•§</p>
                        <p style="margin-bottom: 0;">**‡§∏‡•Å‡§ù‡§æ‡§µ:** ‡§Ü‡§™ ‡§á‡§®‡§Æ‡•á‡§Ç ‡§∏‡•á ‡§ï‡•Å‡§õ ‡§¨‡•ç‡§∞‡•á‡§ï ‡§∏‡§Æ‡§Ø ‡§¨‡§¶‡§≤ ‡§¶‡•á‡§Ç‡•§</p>
                        <ul style="margin-top: 5px; list-style-type: disc; padding-left: 20px;">${overloadAlerts.join('')}</ul>
                    </div>`;
                    resultMessage.innerHTML += alertHTML;
                }
            });

        });
    </script>
</body>
</html>
